package serve

import (
	"encoding/json"
	"fmt"
	"github.com/dexidp/dex/api/v2"
	"github.com/norganna/dex-account-api/rand"
	"golang.org/x/crypto/bcrypt"
	"net/http"
	"regexp"
	"strings"
)

/*
challengeHandler generates a challenge code that you can email to the
client etc, you will require the generated code to be able to create/update
an account.

Generated code is valid for 24 hours.

GET /challenge/email@address.com
Returns: {
    "success": true,      # If successful, otherwise check message field.
	"code": "XV44T9uWH",  # The code to supply to create/update.
	"exists": false       # Whether the specified email address exists.
}
*/
func challengeHandler(o *serveOptions) http.HandlerFunc {
	return func(writer http.ResponseWriter, request *http.Request) {
		if request.Method != http.MethodGet {
			sendErr(writer, "Unsupported method: %s", request.Method)
			return
		}

		parts := strings.Split(request.RequestURI, "/")
		if len(parts) < 3 {
			sendErr(writer, "Must supply an email")
			return
		}

		email := parts[2]
		if !emailValid(email) {
			sendErr(writer, "Supplied email not valid: %s", email)
			return
		}

		resp, err := o.dex.VerifyPassword(
			o.ctx,
			&api.VerifyPasswordReq{
				Email: email,
				Password: "x",
			},
		)

		if err != nil {
			sendErr(writer, err.Error())
			return
		}

		exists := !resp.NotFound
		cred := o.store.AddCode(email, exists)

		sendResponse(writer, http.StatusOK, &jsonChallenge{
			Success: true,
			Code:    cred.Code(),
			Exists:  exists,
		})
	}
}

/*
createHandler creates a new account for a client.

You myst supply a valid challenge code, the account is created with
the email address from the challenge code.

The hash is a bcrypted hash of the actual password, or you can supply the
actual password in the "password" field.

There's no point supplying both hash and password, if both are supplied,
the password will be ignored.

POST /create
Body: {
  "code": "XV44T9uWH",       # A code generated by /challenge.
  "username": "admin",       # The username to use for the account.

  "hash": "$2y$12$qII..m5i"  # The bcrypted password.
                             # OR
  "password": "myPassword"   # The actual password (used if hash not supplied
                             # to generate a hash).
}
Returns: {
  "success": true,    # Whether the account was created.
  "error": "Message"  # If an error the error message.
}
*/
func createHandler(o *serveOptions) http.HandlerFunc {
	return func(writer http.ResponseWriter, request *http.Request) {
		body := &jsonRequest{}
		err := json.NewDecoder(request.Body).Decode(body)
		if err != nil {
			sendErr(writer, "Failed decoding body: %s", err.Error())
			return
		}

		code := body.Code
		if len(code) != 9 {
			sendErr(writer, "Supplied code not valid: %s", code)
			return
		}
		username := body.Username
		if len(username) < 3 {
			sendErr(writer, "Supplied username not valid: %s", username)
			return
		}

		var hash []byte
		if body.Hash != "" {
			hash = []byte(body.Hash)
		} else if body.Password != "" {
			hash, _ = bcrypt.GenerateFromPassword([]byte(body.Password), bcrypt.DefaultCost+2)
		}

		hashLen := len(hash)
		if hashLen > 0 {
			cost, err := bcrypt.Cost(hash)
			if err != nil {
				sendErr(writer, "Supplied hash not valid: %s", hash)
				return
			}

			if cost < bcrypt.DefaultCost {
				sendErr(writer, "Supplied hash not expensive enough: cost %d < %d", cost, bcrypt.DefaultCost)
				return
			}
		} else {
			sendErr(writer, "Hash or password not supplied")
			return
		}

		cred, ok := o.store.GetCode(code)
		if !ok {
			sendErr(writer, "Supplied code does not exist: %s", code)
			return
		}
		if cred.Exists() {
			sendErr(writer, "Supplied code is for an existing account: %s", code)
			return
		}

		if !cred.Use() {
			sendErr(writer, "Code already used")
			return
		}
		resp, err := o.dex.CreatePassword(o.ctx, &api.CreatePasswordReq{
			Password: &api.Password{
				Email:    cred.Email(),
				Hash:     hash,
				Username: username,
				UserId:   rand.SafeString(11),
			},
		})

		if err != nil {
			sendErr(writer, "Error creating account: %s", err.Error())
			return
		}

		if resp.AlreadyExists {
			sendErr(writer, "Account already exists")
			return
		}

		sendSuccess(writer, "Account created: %s", cred.Email())
	}
}

/*
updateHandler updates an existing account for a client.

You must supply a valid challenge code, the email account from the
challenge is used to identify the account to update.

The hash is a bcrypted hash of the actual password, or you can supply the
actual password in the "password" field.

There's no point supplying both hash and password, if both are supplied,
the password will be ignored.

POST /update
Body: {
  "code": "XV44T9uWH",       # A code generated by /challenge.
  "username": "admin",       # If supplied, updates the username of the account.

  "hash": "$2y$12$qII..m5i"  # If supplied, updates the he bcrypted password.
                             # OR
  "password": "myPassword"   # The actual password (used if hash not supplied
                             # to generate a hash).
}
Returns: {
  "success": true,    # Whether the account was created.
  "error": "Message"  # If an error the error message.
}
*/
func updateHandler(o *serveOptions) http.HandlerFunc {
	return func(writer http.ResponseWriter, request *http.Request) {
		body := &jsonRequest{}
		err := json.NewDecoder(request.Body).Decode(body)
		if err != nil {
			sendErr(writer, "Failed decoding body: %s", err.Error())
			return
		}

		code := body.Code
		if len(code) != 9 {
			sendErr(writer, "Supplied code not valid: %s", code)
			return
		}
		username := body.Username
		if username != "" && len(username) < 3 {
			sendErr(writer, "Supplied username not valid: %s", username)
			return
		}

		var hash []byte
		if body.Hash != "" {
			hash = []byte(body.Hash)
		} else if body.Password != "" {
			hash, _ = bcrypt.GenerateFromPassword([]byte(body.Password), bcrypt.DefaultCost+2)
		}

		hashLen := len(hash)
		if hashLen > 0 {
			cost, err := bcrypt.Cost(hash)
			if err != nil {
				sendErr(writer, "Supplied hash not valid: %s", hash)
				return
			}

			if cost < bcrypt.DefaultCost {
				sendErr(writer, "Supplied hash not expensive enough: cost %d < %d", cost, bcrypt.DefaultCost)
				return
			}
		}

		cred, ok := o.store.GetCode(code)
		if !ok {
			sendErr(writer, "Supplied code does not exist: %s", code)
			return
		}
		if !cred.Exists() {
			sendErr(writer, "Supplied code is for a new account: %s", code)
			return
		}

		req := &api.UpdatePasswordReq{
			Email:      cred.Email(),
		}

		if username != "" {
			req.NewUsername = username
		}

		if hashLen > 0 {
			req.NewHash = hash
		}

		if !cred.Use() {
			sendErr(writer, "Code already used")
			return
		}
		resp, err := o.dex.UpdatePassword(o.ctx, req)

		if err != nil {
			sendErr(writer, "Error creating account: %s", err.Error())
			return
		}

		if resp.NotFound {
			sendErr(writer, "Account does not exist")
			return
		}

		sendSuccess(writer, "Account updated: %s", cred.Email())
	}
}

type jsonRequest struct {
	Code     string `json:"code"`
	Username string `json:"username"`
	Hash     string `json:"hash"`
	Password string `json:"password"`
}

type jsonChallenge struct {
	Success bool   `json:"success"`
	Code    string `json:"code"`
	Exists  bool   `json:"exists"`
}

type jsonResult struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
}

func sendErr(writer http.ResponseWriter, message string, args ...interface{}) {
	sendMessage(writer, http.StatusInternalServerError, false, message, args)
}

func sendSuccess(writer http.ResponseWriter, message string, args ...interface{}) {
	sendMessage(writer, http.StatusOK, true, message, args)
}

func sendMessage(writer http.ResponseWriter, status int, success bool, message string, args []interface{}) {
	msg := message
	if len(args) > 0 {
		msg = fmt.Sprintf(msg, args...)
	}
	sendResponse(writer, status, &jsonResult{
		Success: success,
		Message: msg,
	})
}

func sendResponse(writer http.ResponseWriter, code int, object interface{}) {
	writer.WriteHeader(code)
	writer.Header().Set("content-type", "application/json")
	data, _ := json.Marshal(object)
	_, _ = writer.Write([]byte(data))
}

var emailRegex = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
func emailValid(email string) bool {
	if len(email) < 3 && len(email) > 254 {
		return false
	}
	return emailRegex.MatchString(email)
}
